# Plan: Remove Parallelism and Add Rate Limiting for 10 RPM

## Objective

Replace parallel batch execution with sequential processing and add delays between API calls to respect Gemini's 10 requests per minute (RPM) rate limit.

## Changes Required

### File: `generate_audio.py`

#### 1. Update Constants (line 59)

**Before:**
```python
MAX_CONCURRENT_TTS = 5  # Parallel TTS calls
```

**After:**
```python
API_RATE_LIMIT_RPM = 10  # Gemini API rate limit (requests per minute)
API_CALL_DELAY_SEC = 60 / 10  # 6 seconds between calls to stay under limit
```

#### 2. Remove unused import (line 38)

**Remove:**
```python
from concurrent.futures import ThreadPoolExecutor, as_completed
```

#### 3. Replace `generate_all_batches_parallel()` with sequential version (lines 648-692)

**New function:** `generate_all_batches_sequential()`

```python
def generate_all_batches_sequential(
    client: genai.Client,
    batches: list[SegmentBatch],
    speaker_configs_map: dict[str, SpeakerConfig],
    tts_model: str,
    progress_callback: Callable[[int, int], None] | None = None,
    delay_seconds: float = API_CALL_DELAY_SEC,
) -> list[BatchResult]:
    """Generate audio for all batches sequentially with rate limiting.

    Args:
        client: Gemini API client
        batches: List of segment batches
        speaker_configs_map: Mapping of speaker name to config
        tts_model: TTS model to use
        progress_callback: Optional callback for progress updates
        delay_seconds: Delay between API calls (default: 6s for 10 RPM)

    Returns:
        List of BatchResult objects in batch order
    """
    results: list[BatchResult] = []

    for i, batch in enumerate(batches):
        # Rate limiting delay (skip for first request)
        if i > 0:
            logging.debug(f"Rate limit delay: {delay_seconds}s")
            time.sleep(delay_seconds)

        result = generate_batch_with_retry(
            client, batch, speaker_configs_map, tts_model
        )
        results.append(result)

        if progress_callback:
            progress_callback(i + 1, len(batches))

    return results
```

#### 4. Update caller in `generate_audio_from_script()` (line 1167)

**Before:**
```python
results = generate_all_batches_parallel(
    client,
    batches,
    speaker_configs_map,
    script.tts_model,
    progress_callback=progress_callback,
)
```

**After:**
```python
results = generate_all_batches_sequential(
    client,
    batches,
    speaker_configs_map,
    script.tts_model,
    progress_callback=progress_callback,
)
```

## Summary of Changes

| Location | Change |
|----------|--------|
| Line 38 | Remove `ThreadPoolExecutor, as_completed` import |
| Line 59 | Replace `MAX_CONCURRENT_TTS` with `API_RATE_LIMIT_RPM` and `API_CALL_DELAY_SEC` |
| Lines 648-692 | Replace parallel function with sequential + delay |
| Line 1167 | Update function call |

## Verification

1. Run the script with a multi-segment audio script:
   ```bash
   uv run python generate_audio.py audio-scripts/test.md -o test.mp3 --debug
   ```

2. Verify in logs:
   - "Rate limit delay: 6.0s" messages between batches
   - No rate limit errors from Gemini API
   - Batches process sequentially (not simultaneously)

3. Confirm output audio is correctly concatenated
